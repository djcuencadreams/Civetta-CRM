// server/index.ts
import express from "express";
import { setupVite, log } from "./vite";
import { createServer } from "http";
import bodyParser from "body-parser";
import path from "path";
// Importamos lo necesario para obtener la ruta del directorio actual en m√≥dulos ES
import { fileURLToPath } from 'url';
import { dirname } from 'path';
import { registerRoutes } from "./routes";
import { registerOrderRoutes } from "./routes-orders-new";
import { registerConfigurationRoutes } from "./routes-configuration";
import { registerEmailRoutes } from "./routes-email";
import { registerAdditionalRoutes } from "./routes-extension";
// Importamos endpoints de verificaci√≥n de clientes para env√≠os
import { registerCustomerCheckEndpoint } from "./routes-shipping-check-customer";
// Importamos la versi√≥n oficial de las rutas del formulario React
import { registerReactShippingRoutes } from "./routes-shipping-react";
// Importamos el registro de servicios
import { serviceRegistry } from "./services";

// Creamos la ruta al directorio client/dist usando import.meta.url para m√≥dulos ES
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const clientDistPath = path.join(__dirname, "../client/dist");

const app = express();
const server = createServer(app);

app.use(bodyParser.json());

// ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è PRIMERO: REGISTRAR LAS RUTAS REACT PARA ASEGURAR PRIORIDAD ABSOLUTA ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è
console.log("üî•üî•üî• REGISTRANDO RUTAS REACT CON PRIORIDAD ABSOLUTA üî•üî•üî•");

app.use(express.static(clientDistPath)); // Sirve los assets

// ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è INTERCEPCI√ìN NUCLEAR: APLICAR MISMO ENFOQUE DEL PUERTO 3003 AL SERVIDOR PRINCIPAL
// Implementar el mismo middleware radical aqu√≠ para asegurar consistencia en TODOS los puertos

// INTERCEPTAR TODAS LAS RUTAS NO-API (m√°xima prioridad)
app.use((req, res, next) => {
  const requestPath = req.path.toLowerCase();
  
  // Permitir API
  if (requestPath.startsWith('/api/')) {
    return next();
  }
  
  // DETECTAR cualquier ruta relacionada con env√≠os, etiquetas, formularios o embed
  if (
    requestPath.includes('shipping') || 
    requestPath.includes('embed') || 
    requestPath.includes('etiqueta') || 
    requestPath.includes('wordpress') || 
    requestPath.includes('forms')
  ) {
    console.log(`üí•üí•üí• [INTERCEPCI√ìN 3002] ${req.method} ${requestPath} ‚û°Ô∏è FORZANDO REACT`);
    
    // Eliminar cach√©s y forzar tipo
    res.set({
      'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
      'Pragma': 'no-cache',
      'Expires': '0',
      'Surrogate-Control': 'no-store',
      'X-Mode': 'REACT-ONLY-ENFORCED-3002',
      'Content-Type': 'text/html; charset=UTF-8'
    });
    
    return res.sendFile(path.join(clientDistPath, "index.html"), {
      headers: {
        'X-React-Enforced': 'true',
        'X-Content-Type-Options': 'nosniff'
      }
    });
  }
  
  // Para el resto de rutas, continuar normalmente
  return next();
});

// ‚ö†Ô∏è Endpoint "/" para health check de Replit sin romper frontend
app.get("/", (_req, res, next) => {
  if (_req.headers["user-agent"]?.includes("ELB-HealthChecker")) {
    return res.status(200).send("OK");
  }
  return next(); // Pasa al frontend
});

// Creamos funciones para manejar directamente rutas cr√≠ticas de API
// Esta soluci√≥n asegura que estas rutas no sean interceptadas por el middleware de Vite

// Ruta directa para clientes
app.get("/api/customers/:id", async (req, res) => {
  try {
    const id = parseInt(req.params.id);
    console.log(`üîç [API] Solicitud directa para cliente ID: ${id}`);
    res.setHeader('Content-Type', 'application/json');
    
    // Intentamos obtener el cliente de la base de datos usando SQL directo
    const { pool } = await import("@db");
    const result = await pool.query('SELECT * FROM customers WHERE id = $1', [id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: "Cliente no encontrado" });
    }
    
    const customer = result.rows[0];
    res.json(customer);
  } catch (error) {
    console.error('Error obteniendo cliente:', error);
    res.status(500).json({ error: "Error al obtener datos del cliente" });
  }
});

// Ruta directa para etapas del pipeline de oportunidades
app.get("/api/opportunities/pipeline-stages/:brand", async (req, res) => {
  try {
    const { brand } = req.params;
    console.log(`üîç [API] Solicitud directa para etapas del pipeline de marca: ${brand}`);
    res.setHeader('Content-Type', 'application/json');
    
    // Definimos las etapas seg√∫n la marca
    let stages;
    if (brand === 'bride') {
      stages = [
        "Consulta Inicial",
        "Propuesta Enviada",
        "Prueba de Vestido",
        "Ajustes",
        "Confecci√≥n",
        "Entrega Programada",
        "Cerrado Ganado",
        "Cerrado Perdido"
      ];
    } else {
      // Default para Sleepwear u otras marcas
      stages = [
        "Prospecto",
        "Primer Contacto",
        "Propuesta Enviada",
        "Negociaci√≥n",
        "Pedido Confirmado",
        "Cerrado Ganado",
        "Cerrado Perdido"
      ];
    }
    
    res.json(stages);
  } catch (error) {
    console.error('Error obteniendo etapas del pipeline:', error);
    res.status(500).json({ error: "Error al obtener etapas del pipeline" });
  }
});

// Ruta directa para obtener oportunidades (implementaci√≥n b√°sica)
app.get("/api/opportunities", async (req, res) => {
  try {
    console.log(`üîç [API] Solicitud directa para listar oportunidades`);
    res.setHeader('Content-Type', 'application/json');
    
    // Obtenemos oportunidades de la base de datos
    const { pool } = await import("@db");
    const result = await pool.query(`
      SELECT o.*, 
             c.name as customer_name,
             l.name as lead_name
      FROM opportunities o
      LEFT JOIN customers c ON o.customer_id = c.id
      LEFT JOIN leads l ON o.lead_id = l.id
      ORDER BY o.created_at DESC
    `);
    
    // Formateamos la respuesta
    const opportunities = result.rows.map(row => ({
      id: row.id,
      title: row.title,
      description: row.description,
      status: row.status,
      stage: row.stage,
      amount: row.amount,
      brand: row.brand,
      customerId: row.customer_id,
      leadId: row.lead_id,
      assignedUserId: row.assigned_user_id,
      priority: row.priority,
      expectedCloseDate: row.expected_close_date,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      customer: row.customer_name ? { id: row.customer_id, name: row.customer_name } : null,
      lead: row.lead_name ? { id: row.lead_id, name: row.lead_name } : null
    }));
    
    res.json(opportunities);
  } catch (error) {
    console.error('Error obteniendo oportunidades:', error);
    res.status(500).json({ error: "Error al obtener oportunidades" });
  }
});

// Ruta directa para listar interacciones
app.get("/api/interactions", async (req, res) => {
  try {
    console.log(`üîç [API] Solicitud directa para listar interacciones`);
    res.setHeader('Content-Type', 'application/json');
    
    // Obtenemos interacciones de la base de datos
    const { pool } = await import("@db");
    const result = await pool.query(`
      SELECT i.*, 
             c.name as customer_name, 
             l.name as lead_name 
      FROM interactions i
      LEFT JOIN customers c ON i.customer_id = c.id
      LEFT JOIN leads l ON i.lead_id = l.id
      ORDER BY i.created_at DESC
      LIMIT 50
    `);
    
    // Formateamos la respuesta
    const interactions = result.rows.map(row => ({
      id: row.id,
      customerId: row.customer_id,
      leadId: row.lead_id,
      opportunityId: row.opportunity_id,
      type: row.type,
      channel: row.channel,
      content: row.content,
      attachments: row.attachments || [],
      assignedUserId: row.assigned_user_id,
      createdAt: row.created_at,
      isResolved: row.is_resolved,
      resolutionNotes: row.resolution_notes,
      customer: row.customer_name ? { name: row.customer_name } : null,
      lead: row.lead_name ? { name: row.lead_name } : null
    }));
    
    res.json(interactions);
  } catch (error) {
    console.error('Error obteniendo interacciones:', error);
    res.status(500).json({ error: "Error al obtener interacciones" });
  }
});

// Ruta directa para oportunidades con nombre de endpoint alternativo (para debugging)
app.get("/api/debug/opportunities", async (req, res) => {
  try {
    console.log(`üîß [API] Solicitud al endpoint de depuraci√≥n de oportunidades`);
    res.setHeader('Content-Type', 'application/json');
    
    // Obtenemos oportunidades de la base de datos
    const { pool } = await import("@db");
    const result = await pool.query(`
      SELECT o.*, 
             c.name as customer_name,
             l.name as lead_name
      FROM opportunities o
      LEFT JOIN customers c ON o.customer_id = c.id
      LEFT JOIN leads l ON o.lead_id = l.id
      ORDER BY o.created_at DESC
    `);
    
    console.log(`‚úÖ Consulta completada en endpoint de depuraci√≥n, devolviendo ${result.rows.length} oportunidades`);
    res.status(200).json(result.rows);
  } catch (error) {
    console.error('Error en endpoint de depuraci√≥n de oportunidades:', error);
    res.status(500).json({ error: "Error al obtener oportunidades", details: String(error) });
  }
});

// IMPORTANTE: Inicializamos los servicios
console.log("Inicializando servicios...");
serviceRegistry.initializeAll().then(() => {
  console.log("Servicios inicializados correctamente");
  console.log("Registrando rutas de servicios...");
  serviceRegistry.registerAllRoutes(app);
}).catch(error => {
  console.error("Error inicializando servicios:", error);
});

// Registrar las rutas b√°sicas de la API para diagn√≥stico
console.log("Registrando rutas b√°sicas para diagn√≥stico...");
registerRoutes(app);

// Registrar rutas adicionales
console.log("Registrando rutas de pedidos...");
registerOrderRoutes(app);
console.log("Registrando rutas de configuraci√≥n...");
registerConfigurationRoutes(app);
console.log("Registrando rutas de email...");
registerEmailRoutes(app);
console.log("Registrando rutas adicionales...");
registerAdditionalRoutes(app);
console.log("Registrando endpoints para verificaci√≥n de clientes...");
registerCustomerCheckEndpoint(app);
console.log("Registrando rutas del formulario React...");
registerReactShippingRoutes(app);

// NOTA: Las rutas para el formulario de env√≠o React ya fueron registradas al inicio
// directamente en este archivo para garantizar prioridad absoluta
console.log("‚úÖ Rutas para el formulario React ya registradas al inicio del servidor");

// üî• Servir frontend React/Vite (IMPORTANTE: debe ir despu√©s de registrar rutas API)
setupVite(app);

// ‚úÖ Escuchar en puerto asignado por Replit (o 3002 por defecto para evitar conflicto)
const PORT = parseInt(process.env.PORT || "3002", 10);

// Configurar puerto principal
server.listen(PORT, "0.0.0.0", () => {
  log(`üöÄ Servidor escuchando en puerto ${PORT}`);
  
  // Tambi√©n escuchar en puerto 3003 para compatibilidad con URL existente
  try {
    // Crear una instancia secundaria con configuraci√≥n espec√≠fica para servir SOLO React
    const secondaryApp = express();
    
    // ‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è INTERCEPCI√ìN NUCLEAR V2: SOLUCI√ìN ULTRA AGRESIVA
    // Este middleware intercepta TODO y tiene prioridad ABSOLUTA
    secondaryApp.use((req, res, next) => {
      const requestPath = req.path.toLowerCase();
      
      // SOLO dejar pasar solicitudes API
      if (requestPath.startsWith('/api/')) {
        console.log(`‚öôÔ∏è [API-3003] Procesando API: ${requestPath}`);
        return next();
      }
      
      // üí•üí•üí• OVERRRIDE TOTAL - MODO ULTRA NUCLEAR
      console.log(`üî•üî•üî• [MODO ULTRA NUCLEAR] ${req.method} ${requestPath} ‚û°Ô∏è ENVIANDO REDIRECCI√ìN FORZADA`);
      
      // Eliminar TODAS las cach√©s posibles
      res.set({
        'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0',
        'Surrogate-Control': 'no-store',
        'X-Mode': 'REACT-ONLY-ENFORCED-REDIRECT',
        'Content-Type': 'text/html; charset=UTF-8'
      });
      
      // T√ÅCTICA ALTERNATIVA: Enviar HTML de redirecci√≥n agresiva
      // Este HTML tiene m√∫ltiples t√©cnicas de redirecci√≥n por si alguna falla
      return res.sendFile(path.join(__dirname, "../public/shipping-redirect.html"), {
        headers: {
          'X-React-Enforced': 'true',
          'X-Content-Type-Options': 'nosniff'
        }
      });
    });
    
    // Configurar bodyParser despu√©s del middleware de intercepci√≥n
    secondaryApp.use(bodyParser.json());
    
    // Configurar rutas de API necesarias para el formulario
    registerReactShippingRoutes(secondaryApp);
    
    const secondaryServer = createServer(secondaryApp);
    const SECONDARY_PORT = 3003;
    secondaryServer.listen(SECONDARY_PORT, "0.0.0.0", () => {
      log(`üöÄ Servidor secundario escuchando en puerto ${SECONDARY_PORT} (üõ°Ô∏è INTERCEPCI√ìN TOTAL - SOLO REACT)`);
    });
  } catch (error) {
    console.error("No se pudo iniciar el servidor secundario en puerto 3003:", error);
  }
});